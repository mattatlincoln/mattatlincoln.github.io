
<!DOCTYPE html>
<html>
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="chrome=1" />

  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <title>System of Linear Equations 1</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

 <link rel="stylesheet" type="text/css" href="https://jsxgraph.uni-bayreuth.de/distrib/jsxgraph.css" />
 <script type="text/javascript" src="https://jsxgraph.uni-bayreuth.de/distrib/jsxgraphcore.js"></script>  
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

  <!-- General and theme style sheets -->
  <link rel="stylesheet" href="../../../revealjs/css/reveal.css">
  <link rel="stylesheet" href="../../../revealjs/css/theme/beige.css" id="theme">

  <!-- If the query includes 'print-pdf', include the PDF print sheet -->
  <script>
  if( window.location.search.match( /print-pdf/gi ) ) {
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = '../../../revealjs/css/print/pdf.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  }

  </script>

  <!--[if lt IE 9]>
  <script src="../../../revealjs//lib/js/html5shiv.js"></script>
  <![endif]-->

  <!-- Loading the mathjax macro -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
  <!-- Load mathjax -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML"></script>
  <!-- MathJax configuration -->
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true,
      processEnvironments: true
    },
    // Center justify equations in code and markdown cells. Elsewhere
    // we use CSS to left justify single line equations in code cells.
    displayAlign: 'center',
    "HTML-CSS": {
      styles: {'.MathJax_Display': {"margin": 0}},
      linebreaks: { automatic: true }
    }
  });
  </script>
  <!-- End of mathjax configuration -->

  <!-- Get Font-awesome from cdn -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.1.0/css/font-awesome.css">

  <!-- Custom stylesheet, it must be in the same directory as the html file -->
  <link rel="stylesheet" href="../custom.css">

</head>
<body>

<div class="reveal">
  <div class="slides">

    <section data-background-image="https://upload.wikimedia.org/wikipedia/commons/3/3c/Mona_Lisa_eigenvector_grid.png">
      <h2 style="color:white;" id="Numerical Methods Week 6">Numerical Methods Week 6<a class="anchor-link" href="#Numerical Methods Week 6">&#182;</a></h2>
      <h1 style="color:white;" id="System of Linear Equations 2">System of Linear Equations 2<a class="anchor-link" href="#System of Linear Equations 2">&#182;</a></h1>
      <div style="background-color:Lavender; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left:
		  8px; padding-right: 8px; padding-top: 8px; border-radius: 25px;">	
	<p>Learning outcomes:</p>
      </div>
      <br>
      <div style="background-color:Gold; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left:
		  8px; padding-right: 8px; padding-top: 8px; border-radius: 25px;">
        <li> LU decomposition.</li>
        <li> Iterative solution.</li>
      </div>
      <br>
      <div style="background-color:Lavender; margin-left: 20px; margin-right: 20px; padding-bottom: 8px; padding-left:
		  8px; padding-right: 8px; padding-top: 8px; border-radius: 25px;">
 
       <h3>Matt Watkins mwatkins@lincoln.ac.uk<a class="anchor-link" href="#Matt Watkins">&#182;</a></h3>
      </div>
    </section>

    <section>
      <h2 id="Solving a system of Equations">Solving a system of Equations<a class="anchor-link" href="#Solving a system of Equations">&#182;</a></h2>
      <p>We developed two closely related methods to solve a system of equations $\textbf{A}x = b$</p>
      <p>$\textbf{A}$ is a matrix of coefficients of our unknowns, $x$, and $b$ is a vector of constants.</p>
      <p class='fragment'> We rewrote this as an <a href='https://en.wikipedia.org/wiki/Augmented_matrix'>augmented matrix</a><br><br> 
	\[ \left( \begin{array}{cccc|c}
	a_{00} & a_{01} & a_{02} & a_{03} & b_0\\ 
	a_{10} & a_{11} & a_{12} & a_{13} & b_1\\ 
	a_{20} & a_{21} & a_{22} & a_{23} & b_2\\ 
	a_{30} & a_{31} & a_{32} & a_{33} & b_3\\ 
	\end{array} \right)\]
      </p>
      <p  class='fragment'>Gauss elimination reduced this augmented matrix to row echelon form, then back sustitution gave us our solution.</p>
      <p  class='fragment'>Gauss-Jordan elimination reduced this augmented matrix to reduced row echelon form - this could also be used to find the inverse of a matrix.</p>
    </section>

    <section>
      <h2 id="Gaussian Elimination: Code">Gaussian Elimination: Code<a class="anchor-link" href="#Gaussian Elimination: Code">&#182;</a></h2>
      <p>We wrote explicit code for this in Visual C++</p>
      <pre>
	<code>#include &ltiostream>
#include &ltfstream>

void latex_header(std::ofstream &myout) {
    myout &lt&lt "\\documentclass[11pt]{article}\n\n"
         &lt&lt "\\begin{document}\n";
}

void latex_footer(std::ofstream &myout) {
    myout &lt&lt "\\end{document}\n";
}

template &ltint rows, int cols>
void output_matrix(std::ofstream &myout, double (&a)[rows][cols]) {
    myout &lt&lt "\\[ \\left( \\begin{array}{";
    for (int i =0; i&lt cols-1;i++) {
        myout &lt&lt "c";
    }
    myout &lt&lt "|c}\n";
    for (int i =0; i &lt rows; i++) {
        for (int j =0; j &lt cols; j++) {
            myout &lt&lt a[i][j];
            if (j &lt cols-1) myout &lt&lt " & ";
        }
    myout &lt&lt "\\\\ \n";
    }
    myout &lt&lt "\\end{array} \\right) \\]\n";
}

template &ltint rows, int cols>
void gauss_elim(std::ofstream &myout, double (&a)[rows][cols]) {
    double coeff;
    double x[rows];
    for (int i =0; i &lt rows-1; i++) {
        for (int j = i+1; j &lt rows; j++) {
            coeff = a[j][i]/a[i][i];
            for (int k = i; k &lt cols; k++) {
                a[j][k] -= a[i][k]*coeff;
            }
        }
        myout &lt&lt "\n pivoting around row " &lt&lt i &lt&lt "\n\n";
        output_matrix(myout,a);
    }
    // now back substitute
    myout &lt&lt "Back substituting to find $x$:\n";
    for (int i=rows-1;i>=0;i--) {
        x[i] = a[i][cols-1];
        for (int j=i+1; j&ltcols-1; j++) {
            x[i] -= a[i][j]*x[j];
        }
        x[i] /= a[i][i];
    }
    myout &lt&lt "\\[x^T = \\left( \\begin{array}{cccc}\n";
    for (int i = 0; i &lt rows; i++) {
        myout &lt&lt x[i];
        if (i &lt rows-1) myout &lt&lt " & ";
    }
    myout &lt&lt "\\end{array} \\right) \\]\n";
}

int main() {
    std::ofstream myout("Gauss-Elim.tex");
    int n = 4;
    double a[4][5] = {{2,2,4,-2,10},
                      {1,3,2,4,17},
                      {3,1,3,1,18},
                      {1,3,4,2,27},
    };

    latex_header(myout);
    myout &lt&lt "Initial matrix is: \n\n";
    output_matrix(myout, a);

    gauss_elim(myout, a);

    latex_footer(myout);
}	  
        </code>
      </pre>
    </section>    

    <section>
      <h2 id="LU decomposition">LU decomposition<a class="anchor-link" href="#LU decomposition">&#182;</a></h2>
      <p>Again we want to solve $\textbf{Ax - b} = 0$</p>
      <p class='fragment'> Suppose we can rewrite this as 
	\[
	\left( \begin{array}{ccc}
	u_{00} & u_{01} & u_{02} \\ 
	0 & u_{11} & u_{12} \\ 
	0 & 0 & u_{22} \\ 
	\end{array} \right)
	\left( \begin{array}{c}
	x_{0} \\ 
	x_{1} \\ 
	x_{2} \\ 
	\end{array} \right) - 
	\left( \begin{array}{c}
	d_{0} \\ 
	d_{1} \\ 
	d_{2} \\ 
	\end{array} \right)
        = 0
	\]
	which looks similar to Gauss elmination. In matrix notation $$\textbf{Ux - d = 0}$$.
      </p>
      <p class='fragment'>Now, assume there is a lower diagonal matrix $\textbf{L}$ with '1's on the diagonal
	\[
	\left( \begin{array}{ccc}
	1 & 0 & 0 \\ 
	l_{10} & 1 & 0 \\ 
	l_{20} & l_{21} & 1 \\ 
	\end{array} \right)
	\]
      </p>
      <p class='fragment'>that has the property that, premultiplying by $\textbf{L}$ we get
	$$
	\textbf{LUx} - \textbf{Ld} = \textbf{Ax} - \textbf{b}  
	$$
      </p>
    </section>
    
    <section>
      <h2 id="LU decomposition">LU decomposition<a class="anchor-link" href="#LU decomposition">&#182;</a></h2>
      <p> To ensure that
	$$
	\textbf{LUx} - \textbf{Ld} = \textbf{Ax} - \textbf{b}  
	$$
	we require that
      </p>
      <p class='fragment'>
	$$
	\textbf{LU = A}
	$$
	and
	$$
	\textbf{Ld = b}
	$$
      </p>
    </section>

    <section>
      <section>
	<h2 id="Gaussian Elimination">Gaussian Elimination<a class="anchor-link" href="#Gaussian Elimination">&#182;</a></h2>    
	<h3 id="Triangularization">Triangularization<a class="anchor-link" href="#Triangularization">&#182;</a></h3>      
	<p>When we do the Guass elimination method, we actually find all the elements of $\textbf{L}$, we just need to store them. <br> It is the inverse of the matrix we would need to multiply $\textbf{b}$ by to get the correct RHS in the Gauss elmination method. </p>
	<p>Let us take an initial augmented matrix, and record the values that we would scale the $\textbf{b}$ matrix by if it were there: 
	  \[ \left( \begin{array}{cccc}
	  a_{00} & a_{01} & a_{02} & a_{30}\\ 
	  a_{10} & a_{11} & a_{12} & a_{31}\\ 
	  a_{20} & a_{21} & a_{22} & a_{32}\\ 
	  a_{30} & a_{31} & a_{32} & a_{33}\\ 
	  \end{array} \right) \]
	</p>
	<p class=fragment>
	  pivoting around row 0, we remove all entries below the diagonal entry in column 0, doing this we scaled the $\textbf{b}$ matrix by the ratios shown on the right
	  \[ \left( \begin{array}{cccc}
	  a_{00} & a_{01} & a_{02} & a_{30}\\ 
	  0      & a'_{11} & a'_{12} & a'_{31}\\ 
	  0      & a'_{21} & a'_{22} & a'_{32}\\ 
	  0      & a'_{31} & a'_{32} & a'_{33}\\ 
	  \end{array} \right)
	  \qquad
	  \left( \begin{array}{cccc}
	  1 & 0 & 0 & 0\\ 
	  \frac{a_{10}}{a_{00}} &  &  &  & \\ 
	  \frac{a_{20}}{a_{00}} &  &  &  & \\ 
	  \frac{a_{30}}{a_{00}} &  &  &  & \\ 
	  \end{array} \right) \]
	</p>
      </section>
      <section>
	<p>
	  Matrix after pivoting around row 0
	  \[ \left( \begin{array}{cccc}
	  a_{00} & a_{01} & a_{02} & a_{30}\\ 
	  0      & a'_{11} & a'_{12} & a'_{31}\\ 
	  0      & a'_{21} & a'_{22} & a'_{32}\\ 
	  0      & a'_{31} & a'_{32} & a'_{33}\\ 
	  \end{array} \right)
	  \qquad
	  \left( \begin{array}{cccc}
	  1 & 0 & 0 & 0\\ 
	  \frac{a_{10}}{a_{00}} &  &  &  & \\ 
	  \frac{a_{20}}{a_{00}} &  &  &  & \\ 
	  \frac{a_{30}}{a_{00}} &  &  &  & \\ 
	  \end{array} \right) \]
	</p><p class=fragment>
	  Then pivoting around row 1 we remove elements below the diagonal in column 1, and subtract multiples of the 2nd row of $\textbf{b}$ as shown in the right hand matrix
	  \[ \left( \begin{array}{cccc}
	  a_{00} & a_{01} & a_{02} & a_{30}\\ 
	  0      & a'_{11} & a'_{12} & a'_{31}\\ 
	  0      & 0       & a''_{22} & a''_{32}\\ 
	  0      & 0       & a''_{32} & a''_{33}\\ 
	  \end{array} \right)
	  \qquad
	  \left( \begin{array}{cccc}
	  1 &  &  & \\ 
	  \frac{a_{10}}{a_{00}} & 1  &  &  & \\ 
	  \frac{a_{20}}{a_{00}} & \frac{a'_{21}}{a'_{10}} &  &  & \\ 
	  \frac{a_{30}}{a_{00}} & \frac{a'_{31}}{a'_{10}} &  &  & \\ 
	  \end{array} \right) \]
	</p><p class=fragment>	  
	  pivoting around row 2
	  \[ \left( \begin{array}{cccc}
	  a_{00} & a_{01} & a_{02} & a_{30}\\ 
	  0      & a'_{11} & a'_{12} & a'_{31}\\ 
	  0      & 0       & a''_{22} & a''_{32}\\ 
	  0      & 0       & 0        & a'''_{33}\\ 
	  \end{array} \right)
	  \qquad
	  \left( \begin{array}{cccc}
	  1 &  &  & \\ 
	  \frac{a_{10}}{a_{00}} & 1  &  &  & \\ 
	  \frac{a_{20}}{a_{00}} & \frac{a'_{21}}{a'_{11}} &  1 &  & \\ 
	  \frac{a_{30}}{a_{00}} & \frac{a'_{31}}{a'_{11}} & \frac{a''_{32}}{a''_{22}} &  & \\ 
	  \end{array} \right) \]
	</p>
      </section>
      <section>
      	<p>	  
	  we had got to
	  \[ \left( \begin{array}{cccc}
	  a_{00} & a_{01} & a_{02} & a_{30}\\ 
	  0      & a'_{11} & a'_{12} & a'_{31}\\ 
	  0      & 0       & a''_{22} & a''_{32}\\ 
	  0      & 0       & 0        & a'''_{33}\\ 
	  \end{array} \right)
	  \qquad
	  \left( \begin{array}{cccc}
	  1 &  &  & \\ 
	  \frac{a_{10}}{a_{00}} & 1  &  &  & \\ 
	  \frac{a_{20}}{a_{00}} & \frac{a'_{21}}{a'_{11}} &  1 &  & \\ 
	  \frac{a_{30}}{a_{00}} & \frac{a'_{31}}{a'_{11}} & \frac{a''_{32}}{a''_{22}} &  & \\ 
	  \end{array} \right) \]
	</p>
      <p class='fragment'>	  
	  if we fill in the rest of the matrix on the right we have
	  \[ \left( \begin{array}{cccc}
	  a_{00} & a_{01} & a_{02} & a_{30}\\ 
	  0      & a'_{11} & a'_{12} & a'_{31}\\ 
	  0      & 0       & a''_{22} & a''_{32}\\ 
	  0      & 0       & 0        & a'''_{33}\\ 
	  \end{array} \right)
	  \qquad
	  \left( \begin{array}{cccc}
	  1 & 0 & 0 & 0\\ 
	  \frac{a_{10}}{a_{00}} & 1  & 0 & 0 & \\ 
	  \frac{a_{20}}{a_{00}} & \frac{a'_{21}}{a'_{11}} &  1 & 0 & \\ 
	  \frac{a_{30}}{a_{00}} & \frac{a'_{31}}{a'_{11}} & \frac{a''_{32}}{a''_{22}} & 1 & \\ 
	  \end{array} \right) \]
	</p>
      </section>
      <section>
	<p'>
	  We can show for a real system that this new matrix is $\textbf{L}$
	  \[ \left( \begin{array}{cccc}
	  1 & 0 & 0 & 0\\ 
	  \frac{a_{10}}{a_{00}} & 1  & 0 & 0 & \\ 
	  \frac{a_{20}}{a_{00}} & \frac{a'_{21}}{a'_{11}} &  1 & 0 & \\ 
	  \frac{a_{30}}{a_{00}} & \frac{a'_{31}}{a'_{11}} & \frac{a''_{32}}{a''_{22}} & 1 & \\ 
	  \end{array} \right)
	  \left( \begin{array}{cccc}
	  a_{00} & a_{01} & a_{02} & a_{30}\\ 
	  0      & a'_{11} & a'_{12} & a'_{31}\\ 
	  0      & 0       & a''_{22} & a''_{32}\\ 
	  0      & 0       & 0        & a'''_{33}\\ 
	  \end{array} \right)
	  =
	  \left( \begin{array}{cccc}
	  a_{00} & a_{01} & a_{02} & a_{30}\\ 
	  a_{10} & a_{11} & a_{12} & a_{31}\\ 
	  a_{20} & a_{21} & a_{22} & a_{32}\\ 
	  a_{30} & a_{31} & a_{32} & a_{33}\\ 
	  \end{array} \right) \]
	</p>
	<p'>
	$$
	\textbf{LU = A}
	$$
	and
	$$
	\textbf{Ld = b}
	$$
	</p>
	<pre>
	<code>void gauss_elim(std::ofstream &myout, double (&a)[rows][cols]) {
    double coeff;
    double x[rows];
    for (int i =0; i &lt rows-1; i++) {
        for (int j = i+1; j &lt rows; j++) {
            coeff = a[j][i]/a[i][i];
            for (int k = i; k &lt cols; k++) {
                a[j][k] -= a[i][k]*coeff;
            }
        }
        myout &lt&lt "\n pivoting around row " &lt&lt i &lt&lt "\n\n";
        output_matrix(myout,a);
    }
}
        </code>
	</pre>
      </section>
      <section>
	<p>The entries in $\textbf{L}$ are just what I called `coeff` in the code</p>
	<pre>
	<code>void gauss_elim(std::ofstream &myout, double (&a)[rows][cols]) {
    double coeff;
    double x[rows];
    for (int i =0; i &lt rows-1; i++) {
        for (int j = i+1; j &lt rows; j++) {
            coeff = a[j][i]/a[i][i];
	    a[j][i] = coeff;
            for (int k = i+1; k &lt cols; k++) {
                a[j][k] -= a[i][k]*coeff;
            }
        }
    }
}
        </code>
	</pre>
	<p>
	  So only very minor changes in the Gauss elimination code are needed. <br>
	  Note, I have stored the nondiagonal elements of $\textbf{L}$ in what would be the zero elements of the row echelon matrix.
	</p>
      </section>

    </section>
    
    <section>
      <h2 id="LU decomposition">LU decomposition<a class="anchor-link" href="#LU decomposition">&#182;</a></h2>
      <p>The major advantage of LU decompostion is we calculate $\textbf{L}$ and $\textbf{U}$ once, then we can easily find $\textbf{x}$ for any $\textbf{b}$</p>
      <p>Having $\textbf{L}$ we can solve $\textbf{Ld} = \textbf{b}$ for $\textbf{d}$ by forward substitution
	\[ \left( \begin{array}{cccc}
	1 & 0 & 0 & 0\\ 
	\frac{a_{10}}{a_{00}} & 1  & 0 & 0 & \\ 
	\frac{a_{20}}{a_{00}} & \frac{a'_{21}}{a'_{11}} &  1 & 0 & \\ 
	\frac{a_{30}}{a_{00}} & \frac{a'_{31}}{a'_{11}} & \frac{a''_{32}}{a''_{22}} & 1 & \\ 
	\end{array} \right)
	\left( \begin{array}{c}
	d_0 \\ d_1 \\ d_2 \\ d_3 \\
	\end{array} \right)
	=
	\left( \begin{array}{c}
	b_0 \\ b_1 \\ b_2 \\ b_3 \\
	\end{array} \right)\]
	i.e. multiplying out the equations starting from the top row.
      </p>
      <p> Then, having constructed $\textbf{d}$ for the given $\textbf{b}$ we continue exactly like in Gauss Elimination using back substitution to find $\textbf{x}$
	\[\left( \begin{array}{cccc}
	a_{00} & a_{01} & a_{02} & a_{30}\\ 
	0      & a'_{11} & a'_{12} & a'_{31}\\ 
	0      & 0       & a''_{22} & a''_{32}\\ 
	0      & 0       & 0        & a'''_{33}\\ 
	\end{array} \right)
	\left( \begin{array}{c}
	x_0 \\ x_1 \\ x_2 \\ x_3 \\
	\end{array} \right)
	=
	\left( \begin{array}{c}
	d_0 \\ d_1 \\ d_2 \\ d_3 \\
	\end{array} \right)\]

      </p>
    </section>

    <section>
      <h2 id="LU decomposition">LU decomposition<a class="anchor-link" href="#LU decomposition">&#182;</a></h2>
      <p> We can use LU decomposition to find the inverse of a matrix, by setting $b$ to the columns of the identity matrix, $I$.
      </p>
      <p>For example we get the first column of $\textbf{A}^{-1}$ by using $\textbf{b}^T = (1,0,0,0)$
	\[ \left( \begin{array}{cccc}
	1 & 0 & 0 & 0\\ 
	\frac{a_{10}}{a_{00}} & 1  & 0 & 0 & \\ 
	\frac{a_{20}}{a_{00}} & \frac{a'_{21}}{a'_{11}} &  1 & 0 & \\ 
	\frac{a_{30}}{a_{00}} & \frac{a'_{31}}{a'_{11}} & \frac{a''_{32}}{a''_{22}} & 1 & \\ 
	\end{array} \right)
	\left( \begin{array}{c}
	d_0 \\ d_1 \\ d_2 \\ d_3 \\
	\end{array} \right)
	=
	\left( \begin{array}{c}
	1 \\ 0 \\ 0 \\ 0 \\
	\end{array} \right)\]
	i.e. multiplying out the equations starting from the top row.
      </p>
      <p> Then, having constructed $\textbf{d}$ for the given $\textbf{b}$ we continue exactly like in Gauss Elimination using back substitution to find $\textbf{x}$
	\[\left( \begin{array}{cccc}
	a_{00} & a_{01} & a_{02} & a_{30}\\ 
	0      & a'_{11} & a'_{12} & a'_{31}\\ 
	0      & 0       & a''_{22} & a''_{32}\\ 
	0      & 0       & 0        & a'''_{33}\\ 
	\end{array} \right)
	\left( \begin{array}{c}
	A^{-1}_{00} \\ A^{-1}_{10} \\ A^{-1}_{20} \\ A^{-1}_{30} \\
	\end{array} \right)
	=
	\left( \begin{array}{c}
	d_0 \\ d_1 \\ d_2 \\ d_3 \\
	\end{array} \right)\]
	The we build the other columns of $\textbf{A}^{-1}$ from the other unit vectors.
      </p>
    </section>

    <section>
      <h2 id="Summary and Further Reading">Summary and Further Reading<a class="anchor-link" href="#Summary and Further Reading">&#182;</a></h2>
      <p>You should be reading additional material to provide a solid background to what we do in class</p>
      <p>All the textbooks contain sections on solving linear equations, for instance chapter 2 of <a href="http://www.nrbook.com/a/bookcpdf.php">Numerical Recipes</a>.</p>
      <h3>Homework</h3>
      <p></p>
    </section>

    <section>
      <h2 id="Snake">Snake<a class="anchor-link" href="#Snake">&#182;</a></h2>
      <p>Use the arrow keys</p>
      <form><input type="button" onClick="startGame()" value="start game"></form>
      <div id="snakebox" class="jxgbox" style="width:500px; height:500px; overflow:hidden; "></div>
      <script>
    var snakeBoard = JXG.JSXGraph.initBoard('snakebox',{boundingbox: [0, 20, 20, 0],grid:true});
    var snake = {
        points : [[10,11],[10,10]],
        dir : [1,0],
        size: 2,
        newSize: 2,
        speed: 50,
        hitSelf: function(x,y) {
            for (var i=0;i<this.size-1;i++) {
                if (x==this.points[0][i]) if (y==this.points[1][i]) { return true; }
            }
            return false;
        }
    }
    var curve = snakeBoard.create('curve', snake.points , {strokeWidth:20,strokeOpacity:0.5});
    var point = snakeBoard.create('point', [
        Math.round(Math.random()*18)+1,Math.round(Math.random()*18)+1], 
        {strokeColor:'#4CADD4',fillColor:'#4CADD4',strokeWidth:10,name:' '});
    var t = snakeBoard.create('text', [2,1,function() { return snake.size; }], {fontSize:28});

    var setRandomPosition = function()  {
        point.setPositionDirectly(JXG.COORDS_BY_USER,
            [Math.round(Math.random()*18)+1,
            Math.round(Math.random()*18)+1]);
    }
    var keyDown = function (Evt) {
        var code;
        if (!Evt) Evt = window.event;
        if (Evt.which) {
            code = Evt.which;
        } else if (Evt.keyCode) {
            code = Evt.keyCode;
        }
        // 37: left,  38: up,  39: right,  40: down
        if (code==37) { snake.dir = [-1,0]; return false;}
        else if (code==38) { snake.dir = [0,1]; return false;}
        else if (code==39) { snake.dir = [1,0]; return false;}
        else if (code==40) { snake.dir = [0,-1]; return false;}
        return true;
    }
    document.onkeydown = keyDown;

    var crawl = function() {
        if (snake.size>=snake.newSize) {
            snake.points[0].shift();
            snake.points[1].shift();
        }
        var x = snake.points[0][snake.points[0].length-1]+snake.dir[0];
        snake.points[0].push(x);
        var y = snake.points[1][snake.points[1].length-1]+snake.dir[1];
        snake.points[1].push(y);
        snake.size = snake.points[0].length;
        snakeBoard.update();
        if (x>=20 || x<=0 || y>=20 || y<=0 || snake.hitSelf(x,y)) {
            alert('Game over');
        } else {
            if (x==point.X()) if (y==point.Y()) {
                snake.newSize += 5;
                snake.speed -= 10;
                setRandomPosition();
                snakeBoard.update();
            }
            setTimeout(crawl,snake.speed);
        }
    }
    
    var startGame = function () {
        snake.points[0].splice(0,snake.size,10,11);
        snake.points[1].splice(0,snake.size,10,10);
        snake.dir = [1,0];
        snake.size = 2;
        snake.newSize = 2;
        snake.speed = 200;
        setRandomPosition();
        crawl();
     } 
	</script>
    </section>
    
  </div> <!-- slides -->
</div> <!-- reveal -->

  <script>

  require(
    {
      // it makes sense to wait a little bit when you are loading
      // reveal from a cdn in a slow connection environment
      waitSeconds: 15
    },
    [
      "../../../revealjs//lib/js/head.min.js",
      "../../../revealjs//js/reveal.js"
    ],

    function(head, Reveal){

      // Full list of configuration options available here: https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        mouseWheel: false,
        center: false,
        scroll: true,

        // Parallax background image
        //parallaxBackgroundImage: 'https://github.com/mattatlincoln/mattatlincoln.github.io/blob/master/images/CaF2_zoom.jpg?raw=true',
        // Parallax background size
        parallaxBackgroundSize: '2100px 900px', // CSS syntax, e.g. "2100px 900px

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: "../../../revealjs//lib/js/classList.js",
          condition: function() { return !document.body.classList; } },
          { src: "../../../revealjs//plugin/notes/notes.js",
          async: true,
          condition: function() { return !!document.body.classList; } }
        ]
      });

      var update = function(event){
        if(MathJax.Hub.getAllJax(Reveal.getCurrentSlide())){
          MathJax.Hub.Rerender(Reveal.getCurrentSlide());
        }
      };

      Reveal.addEventListener('slidechanged', update);

      var update_scroll = function(event){
        $(".reveal").scrollTop(0);
      };

      Reveal.addEventListener('slidechanged', update_scroll);

    }
  );
  </script>

</body>

</html>
